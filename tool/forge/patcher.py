# forge/patcher.py
# -*- coding: utf-8 -*-

"""
A special "Forge" python library for the P2K ELF SDK toolchain.

Python: 3.10+
License: MIT
Authors: EXL, MotoFan.Ru
Date: 15-Dec-2023
"""

import logging

from pathlib import Path

from .hexer import int2hex_r


def generate_fpa(fw: str, author: str, desc: str, addr: str, hex_str: str, file: Path, undo: str | None = None) -> bool:
	if len(hex_str.strip()) > 0:
		with file.open(mode='w', newline='\r\n') as f_o:
			f_o.write('; This patch file was generated by forge library.\n')
			f_o.write('[Patch_Info]\n')
			f_o.write(f'SW_Ver={fw}\n')
			f_o.write(f'Author={author}\n')
			f_o.write(f'Description={desc}\n')
			f_o.write('[Patch_Code]\n')
			f_o.write(f'{addr}: {hex_str}\n')
			if (undo is not None) and (len(undo.strip()) > 0):
				f_o.write('\n')
				f_o.write('[Patch_Undo]\n')
				f_o.write(f'{addr}: {undo}\n')
		return True
	else:
		logging.error(f'Patch data is empty.')
		return False


def undo_data(addr: int, hex_data: str, undo: Path) -> str | None:
	if undo.is_file() and undo.exists():
		if undo.name.endswith('.bin') or undo.name.endswith('.smg'):
			with undo.open(mode='rb') as f_i:
				file_size = undo.stat().st_size
				patch_size = int(len(hex_data) / 2)
				offset_size = addr + patch_size
				if (addr > file_size) or (offset_size > file_size):
					logging.error(f'Cannot generate patch write/read position beyond file size.')
				else:
					f_i.seek(addr)
					undo_str = f_i.read(patch_size).hex().upper()
					return undo_str
		else:
			logging.error(f'Check binary "*.bin" or "*.smg" undo source file extension.')
	else:
		logging.error(f'Undo source file {undo} is not exist.')
	return None


def bin2fpa(fw: str, autor: str, desc: str, addr: int, binary: Path, fpa: Path, undo: Path | None = None) -> bool:
	if binary.is_file() and binary.exists():
		if binary.name.endswith('.bin'):
			with binary.open(mode='rb') as f_i:
				hex_str = f_i.read().hex().upper()
				if undo is not None:
					undo_str = undo_data(addr, hex_str, undo)
					return generate_fpa(fw, autor, desc, int2hex_r(addr), hex_str, fpa, undo_str)
				return generate_fpa(fw, autor, desc, int2hex_r(addr), hex_str, fpa)
		else:
			logging.error(f'Check binary "*.bin" file extension.')
	else:
		logging.error(f'Binary file {binary} is not exist.')
	return False


def hex2fpa(fw: str, autor: str, desc: str, addr: int, hex_data: str, fpa: Path, undo: Path | None = None) -> bool:
	if undo is not None:
		undo_str = undo_data(addr, hex_data, undo)
		return generate_fpa(fw, autor, desc, int2hex_r(addr), hex_data, fpa, undo_str)
	return generate_fpa(fw, autor, desc, int2hex_r(addr), hex_data, fpa)
