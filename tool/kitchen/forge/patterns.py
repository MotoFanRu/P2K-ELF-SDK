# forge/patterns.py
# -*- coding: utf-8 -*-

"""
The "Forge" python library for the P2K ELF SDK toolchain.

Python: 3.10+
License: MIT
Authors: EXL, MotoFan.Ru
Date: 15-Dec-2023
Version: 1.0
"""

import logging

from pathlib import Path

from .hexer import int2hex
from .hexer import hex2int
from .types import LibraryModel
from .types import MemoryRegion
from .types import PatternModel
from .firmware import determine_memory_region
from .filesystem import check_files_if_exists
from .filesystem import check_files_extensions
from .constants import P2K_TOOL_PAT
from .invoker import invoke_external_command_res
from .symbols import combine_sym_str
from .symbols import dump_sym_file_to_library_model
from .utilities import get_current_datetime_formatted
from .utilities import is_string_filled_by_character


# Generated by Qwen Chat: https://chat.qwen.ai/
# Checks if opcode 2 or 4 byte B/BL/BLX/B.W branches for ARM and Thumb modes.
def is_branch_opcode_arm_thumb(data: bytes, thumb_mode: bool = False, big_endian: bool = True) -> bool:
	if thumb_mode:
		if len(data) >= 2:
			hi: int = data[0] if big_endian else data[1]
			lo: int = data[1] if big_endian else data[0]

			# B.W: 11110HxxxxxLLLLL
			if (hi & 0xF8) in [0xF0, 0xF8]:
				# B.W only
				if (hi & 0xF8) == 0xF0 and (lo & 0x80) == 0x80:
					return True
				# BLX: 1111111100xxxxxxxxxx
				elif hi == 0xFF and (lo & 0xC0) == 0xC0:
					return True
				# BL: 1111110xxxxxxxxx
				elif (hi & 0xF8) == 0xF8:
					return True
				# B.N.W (11110HxxxxxLLLLL)
				elif (hi & 0xF8) == 0xF0 and (lo & 0x80) == 0x00:
					return True
	else:
		if len(data) >= 4:
			if big_endian:
				opcode = (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3]
			else:
				opcode = (data[3] << 24) | (data[2] << 16) | (data[1] << 8) | data[0]

			# B: 0xEA000000
			if (opcode & 0xFC000000) == 0xA0000000:
				return True
			# BL (0xEB000000)
			elif (opcode & 0xFC000000) == 0xB0000000:
				return True

	return False

# Generated by Qwen Chat: https://chat.qwen.ai/
def mask_branch_instructions(hex_data: str, thumb_mode: bool = False) -> str | None:
	if not hex_data:
		return None

	i = 0
	result = []
	byte_list = bytes.fromhex(hex_data)
	while i < len(byte_list):
		# Skip odd addresses.
		if i % 2 != 0:
			result.append(f'{byte_list[i]:02X}')
			i += 1
			continue

		matched = False

		# Check 32-bit opcode first.
		if i + 4 <= len(byte_list):
			chunk = byte_list[i:i+4]
			if is_branch_opcode_arm_thumb(chunk, thumb_mode):
				result.extend(['??', '??', '??', '??'])
				i += 4
				matched = True

		# If not matched, check 16-bit opcode anyway.
		elif not matched and i + 2 <= len(byte_list):
			chunk = byte_list[i:i+2]
			if is_branch_opcode_arm_thumb(chunk, thumb_mode):
				result.extend(['??', '??'])
				i += 2
				matched = True

		# If not matched anyway, just append bytes.
		if not matched:
			result.append(f"{byte_list[i]:02X}")
			i += 1

	result_str: str = ''.join(result)

	return result_str if any(char != '?' for char in result_str) else None


def pat_find(pat_p: Path, cgs_p: Path, base_address: int, ram_trans: bool, out_p: Path) -> bool:
	args: list[str] = [
		str(P2K_TOOL_PAT),
		'-ram-trans' if ram_trans else '-no-ram-trans',
		str(cgs_p),
		str(pat_p),
		str(out_p),
		int2hex(base_address)
	]
	return invoke_external_command_res([pat_p, cgs_p], args)


def pat_append(pat_p: Path, name: str, mode: str, pattern: str) -> None:
	with pat_p.open(mode='a', newline='\r\n') as f_o:
		logging.info(f'Will write "{name} {mode} {pattern}" to "{pat_p}" pattern file.')
		f_o.write(f'{name} {mode} {pattern}')


def sym2pat(sym_p: Path, pat_p: Path, fw_p: Path, offset: int, size: int, irom: bool, argonlv: bool) -> bool:
	files_are_here: bool = check_files_if_exists([sym_p, fw_p])
	sym_extension_is_ok: bool = check_files_extensions([sym_p], ['sym'])
	fw_extension_is_ok: bool = check_files_extensions([fw_p], ['bin', 'smg'])
	if files_are_here and sym_extension_is_ok and fw_extension_is_ok:
		model: LibraryModel = dump_sym_file_to_library_model(sym_p, True)
		if model:
			with fw_p.open(mode='rb') as f_i, pat_p.open(mode='w', newline='\r\n') as f_o:
				f_o.write('# Patterns file was generated by "forge" library.\n')
				f_o.write('# Source Code: https://github.com/MotoFanRu/P2K-ELF-SDK\n')
				f_o.write(f'# File: {fw_p.name}\n')
				f_o.write(f'# Offset: {int2hex(offset)}, {offset}\n')
				f_o.write(f'# Size: {int2hex(size)}, {size}\n')
				f_o.write(f'# Timestamp: {get_current_datetime_formatted()}\n\n')
				for addr, mode, name in model:
					symbol: str = combine_sym_str(addr, mode, name)
					if mode != 'C':
						address: int = hex2int(addr)
						mem_reg: MemoryRegion = determine_memory_region(address, argonlv)
						if (irom and mem_reg == MemoryRegion.IROM) or (not irom and mem_reg == MemoryRegion.ROM):
							if irom:
								f_i.seek(address)  # Offset is "0" here.
							else:
								f_i.seek(address - offset)
							thumb_mode: bool = mode == 'T'
							hex_data_spaced: str = f_i.read(size).hex(' ').upper()
							hex_data: str = mask_branch_instructions(hex_data_spaced, thumb_mode)
							if not hex_data or not hex_data_spaced or is_string_filled_by_character(hex_data, 'F'):
								desc: str = 'because FF-empty, probably Elf Loader API?'
								logging.warning(f'Skip {mem_reg.name} entry: "{symbol}", {desc}')
							else:
								logging.info(f'Write {mem_reg.name} entry: "{symbol}", pattern: {hex_data}.')
								f_o.write(f'# Entry: {symbol}\n')
								f_o.write(f'# Data: {hex_data_spaced}\n')
								f_o.write(f'{name} {mode} {hex_data}\n')
								f_o.write('\n')
						elif mem_reg == MemoryRegion.IRAM:
							desc: str = 'disable RAM-Trans while symbols file generation.'
							logging.warning(f'Skip {mem_reg.name} entry: "{symbol}", {desc}')
						else:
							logging.warning(f'Skip {mem_reg.name} entry: "{symbol}".')
					else:
						logging.warning(f'Skip CONST entry: "{symbol}".')
				return True
	return False


def combine_pat_str(name, mode, count, pattern) -> str:
	return f'{name} {mode} {count} {pattern}'


def generate_pattern_model(pat: Path, sort_by_name: bool) -> PatternModel | None:
	if check_files_if_exists([pat]) and check_files_extensions([pat], ['pts']):
		patterns: PatternModel = []
		with pat.open(mode='r') as f_i:
			for line in f_i.read().splitlines():
				line = line.strip()
				if line and (not line.startswith('#')):
					try:
						splits: list[str] = line.split()
						if len(splits) == 3:
							name, mode, pattern = splits
							patterns.append((name, mode, '0', pattern))
						elif len(splits) == 4:
							name, mode, count, pattern = splits
							patterns.append((name, mode, count, pattern))
						else:
							raise ValueError('Unknown pattern string.')
					except ValueError as error:
						logging.error(f'Cannot parse line: "{line}", error: {error}')
		if sort_by_name:
			patterns = sorted(patterns, key=lambda x: x[0].lower())
		if patterns:
			return patterns
	return None
